---
description: 
globs:
alwaysApply: true
---
# project-rules

这是一个规则文件，用于帮助 AI 理解您的代码库和遵循项目约定。

# 项目规范文档

## 1. 引言

为提高代码质量、可读性、可维护性，统一团队开发规范，特制定此文档。本文档涵盖了技术栈、目录结构、命名、代码风格、接口设计、状态码等方面的规范。

---

## 2. 技术栈

本项目主要基于以下技术栈构建：

- **后端框架**: [NestJS](https://nestjs.com/)
- **编程语言**: [TypeScript](https://www.typescriptlang.org/)
- **API 文档**: [Swagger](https://swagger.io/)
- **代码规范**: Prettier & ESLint

---

## 3. 目录规范

项目采用模块化、分层清晰的目录结构。

```
src
├── common/         # 全局公共模块
│   ├── constants/  # 常量
│   ├── decorators/ # 自定义装饰器
│   ├── dto/        # 数据传输对象
│   ├── enums/      # 枚举
│   ├── filters/    # 异常过滤器
│   ├── guards/     # 路由守卫
│   ├── interceptors/ # 拦截器
│   ├── pipes/      # 管道
│   └── types/      # 全局类型定义
├── config/         # 项目配置
└── modules/        # 业务模块 (按业务划分)
    ├── <module-name>/ # 例如: user (用户模块)
    │   ├── tests/     # 单元测试
    │   ├── types/     # 类型定义
    │   ├── docs/      # 接口文档 (.md)
    │   ├── dto/       # 数据传输对象
    │   ├── entities/  # 数据库实体 (可选)
    │   ├── <module-name>.controller.ts
    │   ├── <module-name>.service.ts
    │   └── <module-name>.module.ts
    └── ...
```

- **`common`**: 存放全局可复用的组件、工具函数、类型定义、常量等。
- **`config`**: 存放项目配置文件，如数据库连接、环境变量等。
- **`modules`**: 存放核心业务模块，每个模块应有自己独立的目录。
  - **`docs`**: 存放该模块的 API 文档。每次更新或新增接口后，都必须在此处更新对应的 `.md` 文档，文档规则参考 `src/modules/auth/docs/auth-api.md`。
  - **`dto`**: 存放数据传输对象 (DTO)。
  - **`entities`**: 存放与数据库表对应的实体类 (可选)。
  - **`controller`**: 负责处理传入的请求和向客户端返回响应。
  - **`service`**: 负责处理业务逻辑。
  - **`module`**: 用于组织模块内的控制器、服务等。

---

## 3. 命名规范

统一的命名规范有助于提高代码的可读性。

- **目录**: 使用小写字母和连字符 `kebab-case`，例如 `user-management`。
- **文件**: 使用 `kebab-case`，并明确文件职责，例如 `user.controller.ts`, `user.service.ts`。
- **类 (Class)**: 使用 `PascalCase`，例如 `UserController`, `AuthService`。
- **接口 (Interface)**: 使用 `PascalCase`，并以 `I` 作为前缀，例如 `IUser`, `IApiResponse`。
- **类型别名 (Type Alias)**: 使用 `PascalCase`，例如 `UserId = string | number`。
- **函数/方法 (Function/Method)**: 使用 `camelCase`，例如 `getUserById`, `createUser`。
- **变量 (Variable)**: 使用 `camelCase`。对于布尔值，建议使用 `is`, `has`, `should` 等前缀，例如 `isLoaded`。
- **常量 (Constant)**: 使用全大写和下划线 `UPPER_CASE_SNAKE_CASE`，例如 `ERROR_CODES`, `DEFAULT_PAGE_SIZE`。
- **枚举 (Enum)**: 使用 `PascalCase` 命名枚举本身和其成员，例如 `enum RoleType { Admin, User }`。

---

## 4. 代码风格

### 4.1. 格式化 (Formatting)

- **工具**: 强烈推荐使用 **Prettier** 统一代码风格。
- **配置**: 在项目根目录创建 `.prettierrc` 文件。

  ```json
  {
    "singleQuote": true,
    "trailingComma": "all",
    "printWidth": 100,
    "tabWidth": 2,
    "semi": true,
    "arrowParens": "always"
  }
  ```

### 4.2. 代码质量 (Linting)

- **工具**: 使用 **ESLint** 进行代码质量检查和风格约束。

## 5. TypeScript 类型规范

- **DTO**: Controller 层与 Service 层之间的数据传输，以及 API 的请求/响应体定义，应使用 DTO (Data Transfer Object) 类，并配合 `class-validator` 进行验证。
- **接口 vs 类型**:
  - 优先使用 `interface` 定义对象和类的结构。
  - 使用 `type` 定义联合类型、交叉类型或工具类型。
- **避免 `any`**: 尽量避免使用 `any` 类型。如果不确定类型，应使用 `unknown` 并进行类型收窄。

---

## 6. 接口规范 (API)

### 6.1. 请求方法

项目统一使用 `GET` 和 `POST` 两种 HTTP 请求方法。

- **`GET`**: 用于所有数据查询请求。
- **`POST`**: 用于所有数据变更（增、删、改）操作。

### 6.2. 路径 (Endpoint)

- **清晰可辨识**: 接口路径应清晰地描述其功能，由动词和名词组成。
- **参数**: 所有请求参数都通过 `GET` 的查询字符串（Query String）或 `POST` 的请求体（Request Body）传递，URL 路径中不携带参数。
- **示例**:
  - `GET /inventory/list` - 获取库存列表
  - `POST /inventory/getById` - 获取单个库存 (参数在请求体中)
  - `POST /inventory/create` - 创建库存
  - `POST /inventory/update` - 更新库存信息
  - `POST /inventory/delete` - 删除库存

### 6.3. 响应体 (Response Body)

所有 API 响应应遵循统一的结构，基于 `IApiResponse` 接口。

```typescript
export interface IApiResponse<T = any> {
  code: number;      // 业务状态码
  message: string;   // 响应消息
  data: T | null;    // 响应数据
}
```

- **成功响应**:
  ```json
  {
    "code": 200,
    "message": "操作成功",
    "data": { "userId": 1, "name": "test" }
  }
  ```
- **失败响应**:
  ```json
  {
    "code": 3001,
    "message": "用户已存在",
    "data": null
  }
  ```
- **分页响应**: 分页数据应包含在 `data` 字段中，并遵循 `IPaginatedResponse` 结构。
  ```json
  {
    "code": 200,
    "message": "查询成功",
    "data": {
      "data": [ ... ],
      "total": 100,
      "page": 1,
      "pageSize": 10,
      "totalPages": 10
    }
  }
  ```

### 6.4. API 文档 (Swagger)

为了确保 API 的可维护性和团队协作效率，所有接口在开发完成后，必须同步更新 Swagger 文档。

- **接口描述**: 使用 `@ApiOperation({ summary: '...' })` 为每个接口添加清晰的中文摘要。
- **响应描述**: 使用 `@ApiResponse({ status: 200, ... })` 描述成功响应的结构。
- **DTO 属性**: 在 DTO 类中，必须为每个属性配置 `@ApiProperty`，并提供以下信息：
  - `description`: 字段的中文描述。
  - `example`: 字段的示例值。
  - `required`: 明确字段是否必填。
  - `enum`: 如果字段是枚举类型，指明可选的枚举值。
- **验证规则**: DTO 属性应配合 `class-validator` 装饰器（如 `@IsNotEmpty()`, `@IsString()`）来定义验证逻辑。

**DTO 示例**:

```typescript
// create-user.dto.ts
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, IsEnum } from 'class-validator';
import { UserRole } from '../user.enum'; // 假设存在

export class CreateUserDto {
  @ApiProperty({
    description: '用户名',
    example: 'testuser',
    required: true,
  })
  @IsNotEmpty({ message: '用户名不能为空' })
  @IsString()
  readonly username: string;

  @ApiProperty({
    description: '用户角色',
    enum: UserRole,
    example: UserRole.Member,
    required: true,
  })
  @IsNotEmpty({ message: '角色不能为空' })
  @IsEnum(UserRole)
  readonly role: UserRole;
}
```

---

## 7. 状态码规范

### 7.1. HTTP 状态码

- **统一使用 `200 OK`**: 只要服务器能够成功响应请求（无论业务逻辑是否成功），HTTP 状态码都应为 `200`。
- **避免使用其他状态码**: 不使用 `4xx` 或 `5xx` 等 HTTP 状态码来传递业务错误信息。所有业务层面的状态都通过业务码在响应体中体现。

### 7.2. 业务码 (Business Code)

业务码用于在 HTTP 状态码的基础上，更精细地表达业务层面的状态。

- **`200`**: 表示业务处理完全成功。
- **分段编码**:
  - `1000-1999`: 通用错误
  - `2000-2999`: 认证相关错误
  - `3000-3999`: 用户相关错误
  - `4000-4999`: 权限相关错误
  - `5000-5999`: 角色相关错误
  - ... 以此类推

所有业务码及其对应的消息应在 `src/common/constants/error-codes.ts` 中统一定义。

---

遵守的核心规则

	1.	优先调用文档解析接口，禁止无依据猜测API功能，确保代码调用准确性。

	2.	面对模糊需求或逻辑时，需主动提示用户补充细节、确认诉求，不盲目生成模糊代码。

	3.	生成业务相关代码方案前，需引导用户关联真实场景数据或用户反馈，辅助验证方案可行性，不基于空想生成代码。

	4.	优先检索并复用现有成熟API、函数库或代码模块，无必要时不主动创建新接口或重复代码，减少冗余。

	5.	生成代码后需自动触发基础验证（如语法检查、逻辑校验），主动提示用户补充测试用例，不生成未经基础验证的代码。

	6.	遵循通用编程架构（如MVC、微服务规范）及行业代码标准，不生成破坏架构一致性、不符合规范的代码。

	7.	遇到未收录的API知识或不确定的技术细节时，需明确告知用户“当前无法确定该信息”，不编造代码逻辑或API用法。

	8.	对用户提供的待优化代码，需先分析原有逻辑关联性，再生成结构化重构方案，禁止无逻辑的盲目修改（如随意删改变量、函数逻辑）。

  9.  禁止修改.env环境配置文件。