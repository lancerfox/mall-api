# 项目编码规范文档

## 1. 引言

为提高代码质量、可读性、可维护性，统一团队开发规范，特制定此文档。本文档涵盖了技术栈、目录结构、命名、代码风格、接口设计、状态码等方面的规范。

---

## 2. 技术栈

本项目主要基于以下技术栈构建：

- **后端框架**: [NestJS](https://nestjs.com/)
- **编程语言**: [TypeScript](https://www.typescriptlang.org/)
- **API 文档**: [Swagger](https://swagger.io/)
- **代码规范**: Prettier & ESLint

---

## 3. 目录规范

项目采用模块化、分层清晰的目录结构。

```
src
├── common/         # 全局公共模块
│   ├── constants/  # 常量
│   ├── decorators/ # 自定义装饰器
│   ├── dto/        # 数据传输对象
│   ├── enums/      # 枚举
│   ├── filters/    # 异常过滤器
│   ├── guards/     # 路由守卫
│   ├── interceptors/ # 拦截器
│   ├── pipes/      # 管道
│   └── types/      # 全局类型定义
├── config/         # 项目配置
├── scripts/        # 构建和部署脚本
└── modules/        # 业务模块 (按业务划分)
    ├── <module-name>/ # 例如: user (用户模块)
    │   ├── tests/     # 单元测试
    │   ├── types/     # 类型定义
    │   ├── docs/      # 接口文档 (.md)
    │   ├── dto/       # 数据传输对象
    │   ├── entities/  # 数据库实体 (可选)
    │   ├── <module-name>.controller.ts
    │   ├── <module-name>.service.ts
    │   └── <module-name>.module.ts
    └── ...
```

- **`common`**: 存放全局可复用的组件、工具函数、类型定义、常量等。
- **`config`**: 存放项目配置文件，如数据库连接、环境变量等。
- **`scripts`**: 存放构建、部署等自动化脚本。
- **`modules`**: 存放核心业务模块，每个模块应有自己独立的目录。
  - **`tests`**: 存放单元测试和集成测试文件。
  - **`types`**: 存放模块专属的类型定义。
  - **`docs`**: 存放该模块的 API 文档。每次更新或新增接口后，都必须在此处更新对应的 `.md` 文档。
  - **`dto`**: 存放数据传输对象 (DTO)。
  - **`entities`**: 存放与数据库表对应的实体类 (可选)。
  - **`controller`**: 负责处理传入的请求和向客户端返回响应。
  - **`service`**: 负责处理业务逻辑。
  - **`module`**: 用于组织模块内的控制器、服务等。

---

## 4. 命名规范

统一的命名规范有助于提高代码的可读性。

### 4.1. 目录和文件命名
- **目录**: 使用小写字母和连字符 `kebab-case`，例如 `user-management`。
- **文件**: 使用 `kebab-case`，并明确文件职责，例如 `user.controller.ts`, `user.service.ts`。

### 4.2. 代码元素命名
- **类 (Class)**: 使用 `PascalCase`，例如 `UserController`, `AuthService`。
- **接口 (Interface)**: 使用 `PascalCase`，并以 `I` 作为前缀，例如 `IUser`, `IApiResponse`。
- **类型别名 (Type Alias)**: 使用 `PascalCase`，例如 `UserId = string | number`。
- **函数/方法 (Function/Method)**: 使用 `camelCase`，例如 `getUserById`, `createUser`。
- **变量 (Variable)**: 使用 `camelCase`。对于布尔值，建议使用 `is`, `has`, `should` 等前缀，例如 `isLoaded`。
- **常量 (Constant)**: 使用全大写和下划线 `UPPER_CASE_SNAKE_CASE`，例如 `ERROR_CODES`, `DEFAULT_PAGE_SIZE`。
- **枚举 (Enum)**: 使用 `PascalCase` 命名枚举本身和其成员，例如 `enum RoleType { Admin, User }`。

---

## 5. 代码风格

### 5.1. 格式化 (Formatting)

- **工具**: 强烈推荐使用 **Prettier** 统一代码风格。
- **配置**: 在项目根目录创建 `.prettierrc` 文件。

  ```json
  {
    "singleQuote": true,
    "trailingComma": "all",
    "printWidth": 100,
    "tabWidth": 2,
    "semi": true,
    "arrowParens": "always"
  }
  ```

### 5.2. 代码质量 (Linting)

- **工具**: 使用 **ESLint** 进行代码质量检查和风格约束。
- **规则**: 除Prettier格式化外，建议启用以下规则以提升代码质量：
  - `@typescript-eslint/explicit-function-return-type`: 强制函数返回类型明确
  - `@typescript-eslint/no-explicit-any`: 禁止使用 `any` 类型
  - `@typescript-eslint/no-unused-vars`: 禁止未使用的变量
  - `prefer-const`: 优先使用 `const` 声明变量
  - `eqeqeq`: 强制使用严格相等比较

---

## 6. TypeScript 类型规范

- **DTO**: Controller 层与 Service 层之间的数据传输，以及 API 的请求/响应体定义，应使用 DTO (Data Transfer Object) 类，并配合 `class-validator` 进行验证。
- **接口 vs 类型**:
  - 优先使用 `interface` 定义对象和类的结构。
  - 使用 `type` 定义联合类型、交叉类型或工具类型。
- **避免 `any`**: 尽量避免使用 `any` 类型。如果不确定类型，应使用 `unknown` 并进行类型收窄。
- **泛型使用**: 在编写可复用的组件或函数时，优先考虑使用泛型以增强类型安全。

---

## 7. 接口规范 (API)

### 7.1. 请求方法

项目统一使用 `GET` 和 `POST` 两种 HTTP 请求方法。

- **`GET`**: 用于所有数据查询请求。
- **`POST`**: 用于所有数据变更（增、删、改）操作。

### 7.2. 路径 (Endpoint)

- **清晰可辨识**: 接口路径应清晰地描述其功能，由动词和名词组成。
- **参数**: 所有请求参数都通过 `GET` 的查询字符串（Query String）或 `POST` 的请求体（Request Body）传递，URL 路径中不携带参数。
- **示例**:
  - `GET /inventory/list` - 获取库存列表
  - `POST /inventory/getById` - 获取单个库存 (参数在请求体中)
  - `POST /inventory/create` - 创建库存
  - `POST /inventory/update` - 更新库存信息
  - `POST /inventory/delete` - 删除库存

### 7.3. 响应体 (Response Body)

所有 API 响应应遵循统一的结构，基于 `IApiResponse` 接口。

```typescript
export interface IApiResponse<T = any> {
  code: number;      // 业务状态码
  message: string;   // 响应消息
  data: T | null;    // 响应数据
}
```

- **成功响应**:
  ```json
  {
    "code": 200,
    "message": "操作成功",
    "data": { "userId": 1, "name": "test" }
  }
  ```
- **失败响应**:
  ```json
  {
    "code": 3001,
    "message": "用户已存在",
    "data": null
  }
  ```
- **分页响应**: 分页数据应包含在 `data` 字段中，并遵循 `IPaginatedResponse` 结构。
  ```json
  {
    "code": 200,
    "message": "查询成功",
    "data": {
      "data": [ ... ],
      "total": 100,
      "page": 1,
      "pageSize": 10,
      "totalPages": 10
    }
  }
  ```

### 7.4. API 文档 (Swagger)

为了确保 API 的可维护性和团队协作效率，所有接口在开发完成后，必须同步更新 Swagger 文档。

- **接口描述**: 使用 `@ApiOperation({ summary: '...' })` 为每个接口添加清晰的中文摘要。
- **响应描述**: 使用 `@ApiResponse({ status: 200, ... })` 描述成功响应的结构。
- **DTO 属性**: 在 DTO 类中，必须为每个属性配置 `@ApiProperty`，并提供以下信息：
  - `description`: 字段的中文描述。
  - `example`: 字段的示例值。
  - `required`: 明确字段是否必填。
  - `enum`: 如果字段是枚举类型，指明可选的枚举值。
- **验证规则**: DTO 属性应配合 `class-validator` 装饰器（如 `@IsNotEmpty()`, `@IsString()`）来定义验证逻辑。

**DTO 示例**:

```
// create-user.dto.ts
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, IsEnum } from 'class-validator';
import { UserRole } from '../user.enum'; // 假设存在

export class CreateUserDto {
  @ApiProperty({
    description: '用户名',
    example: 'testuser',
    required: true,
  })
  @IsNotEmpty({ message: '用户名不能为空' })
  @IsString()
  readonly username: string;

  @ApiProperty({
    description: '用户角色',
    enum: UserRole,
    example: UserRole.Member,
    required: true,
  })
  @IsNotEmpty({ message: '角色不能为空' })
  @IsEnum(UserRole)
  readonly role: UserRole;
}
```

---

## 8. 状态码规范

### 8.1. HTTP 状态码

- **统一使用 `200 OK`**: 只要服务器能够成功响应请求（无论业务逻辑是否成功），HTTP 状态码都应为 `200`。
- **避免使用其他状态码**: 不使用 `4xx` 或 `5xx` 等 HTTP 状态码来传递业务错误信息。所有业务层面的状态都通过业务码在响应体中体现。

### 8.2. 业务码 (Business Code)

业务码用于在 HTTP 状态码的基础上，更精细地表达业务层面的状态。

- **`200`**: 表示业务处理完全成功。
- **分段编码**:
  - `1000-1999`: 通用错误
  - `2000-2999`: 认证相关错误
  - `3000-3999`: 用户相关错误
  - `4000-4999`: 权限相关错误
  - `5000-5999`: 角色相关错误
  - ... 以此类推

所有业务码及其对应的消息应在 `src/common/constants/error-codes.ts` 中统一定义。

---

## 9. 异常处理规范

### 9.1. 全局异常过滤器
- 使用 NestJS 提供的全局异常过滤器 (`@nestjs/common` 中的 `BaseExceptionFilter`) 或自定义过滤器统一处理未捕获的异常
- 自定义异常应继承 `HttpException` 或使用 NestJS 内置异常类型

### 9.2. 业务异常处理
- 对于业务逻辑中的错误情况，应抛出自定义业务异常，包含明确的错误码和消息
- 在控制器层捕获并记录异常日志（如使用 `@nestjs/common` 的 `Logger`）

---

## 10. 注释规范

### 10.1. 代码注释
- 对于复杂逻辑或算法，应添加行内注释或块注释解释其实现原理
- 使用 `//` 进行单行注释，`/* */` 进行多行注释
- 避免无意义的注释，注释应随代码更新保持同步

### 10.2. 函数/方法注释
- 使用 JSDoc 风格的注释为公共方法添加文档
- 标注参数类型、返回值类型、可能抛出的异常、功能描述等

```
/**
 * 根据ID获取用户信息
 * @param userId - 用户ID
 * @returns Promise<User> - 用户信息对象
 * @throws {NotFoundException} - 当用户不存在时抛出
 */
async getUserById(userId: string): Promise<User> {
  // 实现逻辑
}
```

---

## 11. 安全规范

### 11.1. 输入验证
- 所有来自客户端的输入都必须进行严格验证，防止注入攻击
- 使用 `class-validator` 在 DTO 中定义验证规则
- 对于文件上传，应限制文件类型和大小

### 11.2. 敏感信息保护
- 敏感信息（如密码、密钥）不得在代码中硬编码
- 使用环境变量或配置中心存储敏感信息
- 对于敏感数据传输，应使用 HTTPS 协议

## 13. 数据库实体规范

### 13.1. 实体定义
- 所有数据库实体应使用TypeORM的@Entity装饰器定义
- 每个实体应继承统一的基类（如果适用），包含通用字段如id、createdAt、updatedAt
- 所有数据库字段必须使用适当的类型注解
- 对于需要加密的字段（如密码），应在@BeforeInsert和@BeforeUpdate钩子中进行加密处理

### 13.2. 字段定义
- 主键统一使用@PrimaryGeneratedColumn('uuid')生成UUID
- 使用@CreateDateColumn和@UpdateDateColumn自动管理创建和更新时间
- 字符串字段应设置适当的长度限制
- 对于可选字段使用@IsOptional装饰器

### 13.3. 关联关系
- 使用TypeORM的关联装饰器（@ManyToOne, @OneToMany, @ManyToMany等）定义实体间关系
- 正确设置cascade和eager选项，避免不必要的性能问题
- 使用@JoinTable装饰器定义多对多关系的中间表

## 14. DTO验证规范

### 14.1. 验证规则
- 所有DTO类中的字段都应使用class-validator装饰器进行验证
- 使用@IsString, @IsNumber, @IsBoolean等类型验证装饰器
- 使用@IsNotEmpty, @MinLength, @MaxLength等业务规则验证装饰器
- 使用@IsOptional装饰器标记可选字段

### 14.2. 自定义验证
- 对于复杂验证逻辑，可创建自定义验证器类并使用@Validate装饰器
- 所有验证错误都应有清晰的中文错误消息

## 15. 装饰器使用规范

### 15.1. 自定义装饰器
- 创建自定义装饰器以简化通用功能，如@CurrentUser, @Permissions
- 装饰器应有清晰的用途和文档说明
- 为装饰器创建对应的类型定义

### 15.2. NestJS装饰器
- 按照NestJS标准使用内置装饰器，如@Body, @Query, @Param等
- 使用@ApiProperty装饰器为Swagger文档提供字段信息

## 16. 枚举和常量规范

### 16.1. 枚举定义
- 枚举使用PascalCase命名，枚举成员也使用PascalCase
- 为枚举添加JSDoc注释说明用途
- 在TypeScript中使用enum关键字定义枚举

### 16.2. 常量定义
- 错误码常量应使用ERROR_CODES命名空间统一管理
- 权限常量应使用PERMISSIONS命名空间统一管理
- 所有常量应定义在对应的constants目录中
- 使用const断言（as const）确保常量不可变

## 17. 异常处理规范

### 17.1. 自定义异常
- 业务异常统一使用BusinessException类
- BusinessException应包含错误码和错误消息
- 不同类型的错误应使用不同的错误码

### 17.2. 异常处理策略
- 在Service层抛出业务异常
- 由全局异常过滤器统一处理未捕获的异常
- 对于可预见的错误，应使用BusinessException而非标准异常

## 18. 权限与安全规范

### 18.1. 权限控制
- 使用JWT进行身份验证
- 通过RolesGuard和Permissions装饰器实现基于角色和权限的访问控制
- 实现超级管理员权限，拥有所有操作权限
- 权限检查需要验证用户状态（激活/锁定/禁用）

### 18.2. 安全措施
- 用户密码必须使用bcrypt等安全算法进行哈希
- 实现登录失败次数限制，防止暴力破解
- 敏感数据（如密码）不得在日志中明文记录
- 验证用户输入以防止注入攻击

## 19. 环境变量管理规范

### 19.1. 环境变量定义
- 使用nestjs/config模块管理环境变量
- 在应用启动时验证必需的环境变量
- 不同环境（开发、测试、生产）使用不同的配置文件

### 19.2. 配置访问
- 通过ConfigService安全地访问环境变量
- 不得在代码中硬编码敏感信息

## 20. 工具函数和类型规范

### 20.1. 工具函数
- 通用工具函数应放在src/common/utils目录中
- 工具函数应是纯函数，无副作用
- 提供详细的JSDoc文档说明函数用途、参数和返回值

### 20.2. 类型定义
- 全局类型定义应放在src/common/types目录中
- 使用interface定义对象结构，type定义联合类型
- 为复杂的类型结构提供清晰的文档

## 21. 代码组织与模块规范

### 21.1. 模块依赖
- 使用forwardRef解决模块间的循环依赖问题
- 避免不必要的模块导入，只导入实际使用的模块
- 模块间的依赖关系应清晰明确

### 21.2. API版本控制
- 虽然当前未实现API版本控制，但建议在路径中使用版本号（如/api/v1/）以便将来扩展

## 22. 分页查询规范

### 22.1. 分页参数
- 统一使用page和pageSize作为分页参数
- 默认页码为1，默认每页大小为10
- 响应遵循IPaginatedResponse结构

### 22.2. DTO分页参数定义规范
- 分页参数应使用可选类型（page?: number），并提供默认值
- 使用安全的整数转换函数处理分页参数，防止NaN或非数字值
- 使用class-validator装饰器进行参数验证：
  - `@IsOptional()` 标记可选参数
  - `@IsInt()` 验证整数类型
  - `@Min(1)` 限制最小值为1
- 使用class-transformer装饰器进行类型转换：
  - `@Transform(safeTransformToInt)` 使用安全转换函数

### 22.3. 分页DTO示例
```
import { ApiPropertyOptional } from '@nestjs/swagger';
import { Transform } from 'class-transformer';
import { IsOptional, IsInt, Min } from 'class-validator';

// 安全整数转换函数
const safeTransformToInt = ({ value }: { value: unknown }): number | undefined => {
  if (value === null || value === undefined || value === '') {
    return undefined;
  }
  
  if (typeof value === 'number' && Number.isFinite(value)) {
    return Math.floor(value);
  }
  
  if (typeof value === 'string') {
    const num = parseInt(value, 10);
    return isNaN(num) ? undefined : num;
  }
  
  return undefined;
};

export class PaginationDto {
  @ApiPropertyOptional({
    description: '页码',
    example: 1,
    minimum: 1,
    type: Number,
  })
  @Transform(safeTransformToInt)
  @IsOptional()
  @IsInt({ message: '页码必须是整数' })
  @Min(1, { message: '页码不能小于1' })
  page?: number = 1;

  @ApiPropertyOptional({
    description: '每页数量',
    example: 10,
    minimum: 1,
    type: Number,
  })
  @Transform(safeTransformToInt)
  @IsOptional()
  @IsInt({ message: '每页数量必须是整数' })
  @Min(1, { message: '每页数量不能小于1' })
  pageSize?: number = 10;
}
```

### 22.4. 服务层分页处理规范
- 在服务层处理分页参数时，应提供默认值防止undefined错误
- 使用空值合并操作符提供默认值：
  ```typescript
  const page = query.page ?? 1;
  const pageSize = query.pageSize ?? 10;
  ```
- 正确计算skip值用于数据库查询：
  ```typescript
  const skip = (page - 1) * pageSize;
  ```

### 22.5. 分页响应结构
- 分页响应应包含以下字段：
  - `list`: 数据列表
  - `total`: 总数量
  - `page`: 当前页码
  - `pageSize`: 每页数量
  - `totalPages`: 总页数
- 响应示例：
  ```json
  {
    "code": 200,
    "message": "查询成功",
    "data": {
      "list": [...],
      "total": 100,
      "page": 1,
      "pageSize": 10,
      "totalPages": 10
    }
  }
  ```

### 22.6. 分页实现示例
```
async getUserList(query: QueryUserDto): Promise<UserListResponseDto> {
  // 提供默认值防止undefined错误
  const page = query.page ?? 1;
  const pageSize = query.pageSize ?? 10;
  const skip = (page - 1) * pageSize;

  const [users, total] = await this.userRepository.findAndCount({
    skip,
    take: pageSize,
  });

  return {
    list: users,
    total,
    page,
    pageSize,
    totalPages: Math.ceil(total / pageSize),
  };
}
```

## 23. 日志和监控规范

### 23.1. 日志记录
- 使用NestJS内置的Logger或第三方日志库记录应用日志
- 记录关键业务操作和错误信息
- 敏感信息（如密码）不得记录在日志中

### 23.2. 监控指标
- 记录关键业务指标，如登录尝试统计
- 实现操作日志记录，追踪用户操作

## 24. 核心规则

作为项目开发人员，必须严格遵守以下核心规则，确保代码质量和项目一致性：

1. **准确性原则**  
   优先调用官方文档解析接口，禁止无依据猜测API功能，确保代码调用准确性。
2. **沟通明确原则**  
   面对模糊需求或逻辑时，需主动提示用户补充细节、确认诉求，不盲目生成模糊代码。
3. **数据驱动原则**  
   生成业务相关代码方案前，需引导用户关联真实场景数据或用户反馈，辅助验证方案可行性，不基于空想生成代码。
4. **复用优先原则**  
   优先检索并复用现有成熟API、函数库或代码模块，无必要时不主动创建新接口或重复代码，减少冗余。
5. **验证保障原则**  
   生成代码后需自动触发基础验证（如语法检查、逻辑校验），主动提示用户补充测试用例，不生成未经基础验证的代码。
6. **架构一致原则**  
   遵循通用编程架构（如MVC、微服务规范）及行业代码标准，不生成破坏架构一致性、不符合规范的代码。
7. **诚实透明原则**  
   遇到未收录的API知识或不确定的技术细节时，需明确告知用户"当前无法确定该信息"，不编造代码逻辑或API用法。
8. **逻辑完整原则**  
   对用户提供的待优化代码，需先分析原有逻辑关联性，再生成结构化重构方案，禁止无逻辑的盲目修改（如随意删改变量、函数逻辑）。
9. **环境安全原则**  
   禁止修改.env环境配置文件。