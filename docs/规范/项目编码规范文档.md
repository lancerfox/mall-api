# 项目编码规范文档

## 1. 引言

为提高代码质量、可读性、可维护性，统一团队开发规范，特制定此文档。本文档涵盖了技术栈、目录结构、命名、代码风格、接口设计、状态码等方面的规范。

---

## 2. 技术栈

本项目主要基于以下技术栈构建：

- **后端框架**: [NestJS](https://nestjs.com/)
- **编程语言**: [TypeScript](https://www.typescriptlang.org/)
- **API 文档**: [Swagger](https://swagger.io/)
- **代码规范**: Prettier & ESLint

---

## 3. 目录规范

项目采用模块化、分层清晰的目录结构。

```
src
├── common/         # 全局公共模块
│   ├── constants/  # 常量
│   ├── decorators/ # 自定义装饰器
│   ├── dto/        # 数据传输对象
│   ├── enums/      # 枚举
│   ├── filters/    # 异常过滤器
│   ├── guards/     # 路由守卫
│   ├── interceptors/ # 拦截器
│   ├── pipes/      # 管道
│   └── types/      # 全局类型定义
├── config/         # 项目配置
├── scripts/        # 构建和部署脚本
└── modules/        # 业务模块 (按业务划分)
    ├── <module-name>/ # 例如: user (用户模块)
    │   ├── tests/     # 单元测试
    │   ├── types/     # 类型定义
    │   ├── docs/      # 接口文档 (.md)
    │   ├── dto/       # 数据传输对象
    │   ├── entities/  # 数据库实体 (可选)
    │   ├── <module-name>.controller.ts
    │   ├── <module-name>.service.ts
    │   └── <module-name>.module.ts
    └── ...
```

- **`common`**: 存放全局可复用的组件、工具函数、类型定义、常量等。
- **`config`**: 存放项目配置文件，如数据库连接、环境变量等。
- **`scripts`**: 存放构建、部署等自动化脚本。
- **`modules`**: 存放核心业务模块，每个模块应有自己独立的目录。
  - **`tests`**: 存放单元测试和集成测试文件。
  - **`types`**: 存放模块专属的类型定义。
  - **`docs`**: 存放该模块的 API 文档。每次更新或新增接口后，都必须在此处更新对应的 `.md` 文档。
  - **`dto`**: 存放数据传输对象 (DTO)。
  - **`entities`**: 存放与数据库表对应的实体类 (可选)。
  - **`controller`**: 负责处理传入的请求和向客户端返回响应。
  - **`service`**: 负责处理业务逻辑。
  - **`module`**: 用于组织模块内的控制器、服务等。

---

## 4. 命名规范

统一的命名规范有助于提高代码的可读性。

### 4.1. 目录和文件命名
- **目录**: 使用小写字母和连字符 `kebab-case`，例如 `user-management`。
- **文件**: 使用 `kebab-case`，并明确文件职责，例如 `user.controller.ts`, `user.service.ts`。

### 4.2. 代码元素命名
- **类 (Class)**: 使用 `PascalCase`，例如 `UserController`, `AuthService`。
- **接口 (Interface)**: 使用 `PascalCase`，并以 `I` 作为前缀，例如 `IUser`, `IApiResponse`。
- **类型别名 (Type Alias)**: 使用 `PascalCase`，例如 `UserId = string | number`。
- **函数/方法 (Function/Method)**: 使用 `camelCase`，例如 `getUserById`, `createUser`。
- **变量 (Variable)**: 使用 `camelCase`。对于布尔值，建议使用 `is`, `has`, `should` 等前缀，例如 `isLoaded`。
- **常量 (Constant)**: 使用全大写和下划线 `UPPER_CASE_SNAKE_CASE`，例如 `ERROR_CODES`, `DEFAULT_PAGE_SIZE`。
- **枚举 (Enum)**: 使用 `PascalCase` 命名枚举本身和其成员，例如 `enum RoleType { Admin, User }`。

---

## 5. 代码风格

### 5.1. 格式化 (Formatting)

- **工具**: 强烈推荐使用 **Prettier** 统一代码风格。
- **配置**: 在项目根目录创建 `.prettierrc` 文件。

  ```json
  {
    "singleQuote": true,
    "trailingComma": "all",
    "printWidth": 100,
    "tabWidth": 2,
    "semi": true,
    "arrowParens": "always"
  }
  ```

### 5.2. 代码质量 (Linting)

- **工具**: 使用 **ESLint** 进行代码质量检查和风格约束。
- **规则**: 除Prettier格式化外，建议启用以下规则以提升代码质量：
  - `@typescript-eslint/explicit-function-return-type`: 强制函数返回类型明确
  - `@typescript-eslint/no-explicit-any`: 禁止使用 `any` 类型
  - `@typescript-eslint/no-unused-vars`: 禁止未使用的变量
  - `prefer-const`: 优先使用 `const` 声明变量
  - `eqeqeq`: 强制使用严格相等比较

---

## 6. TypeScript 类型规范

- **DTO**: Controller 层与 Service 层之间的数据传输，以及 API 的请求/响应体定义，应使用 DTO (Data Transfer Object) 类，并配合 `class-validator` 进行验证。
- **接口 vs 类型**:
  - 优先使用 `interface` 定义对象和类的结构。
  - 使用 `type` 定义联合类型、交叉类型或工具类型。
- **避免 `any`**: 尽量避免使用 `any` 类型。如果不确定类型，应使用 `unknown` 并进行类型收窄。
- **泛型使用**: 在编写可复用的组件或函数时，优先考虑使用泛型以增强类型安全。

---

## 7. 接口规范 (API)

### 7.1. 请求方法

项目统一使用 `GET` 和 `POST` 两种 HTTP 请求方法。

- **`GET`**: 用于所有数据查询请求。
- **`POST`**: 用于所有数据变更（增、删、改）操作。

### 7.2. 路径 (Endpoint)

- **清晰可辨识**: 接口路径应清晰地描述其功能，由动词和名词组成。
- **参数**: 所有请求参数都通过 `GET` 的查询字符串（Query String）或 `POST` 的请求体（Request Body）传递，URL 路径中不携带参数。
- **示例**:
  - `GET /inventory/list` - 获取库存列表
  - `POST /inventory/getById` - 获取单个库存 (参数在请求体中)
  - `POST /inventory/create` - 创建库存
  - `POST /inventory/update` - 更新库存信息
  - `POST /inventory/delete` - 删除库存

### 7.3. 响应体 (Response Body)

所有 API 响应应遵循统一的结构，基于 `IApiResponse` 接口。

```typescript
export interface IApiResponse<T = any> {
  code: number;      // 业务状态码
  message: string;   // 响应消息
  data: T | null;    // 响应数据
}
```

- **成功响应**:
  ```json
  {
    "code": 200,
    "message": "操作成功",
    "data": { "userId": 1, "name": "test" }
  }
  ```
- **失败响应**:
  ```json
  {
    "code": 3001,
    "message": "用户已存在",
    "data": null
  }
  ```
- **分页响应**: 分页数据应包含在 `data` 字段中，并遵循 `IPaginatedResponse` 结构。
  ```json
  {
    "code": 200,
    "message": "查询成功",
    "data": {
      "data": [ ... ],
      "total": 100,
      "page": 1,
      "pageSize": 10,
      "totalPages": 10
    }
  }
  ```

### 7.4. API 文档 (Swagger)

为了确保 API 的可维护性和团队协作效率，所有接口在开发完成后，必须同步更新 Swagger 文档。

- **接口描述**: 使用 `@ApiOperation({ summary: '...' })` 为每个接口添加清晰的中文摘要。
- **响应描述**: 使用 `@ApiResponse({ status: 200, ... })` 描述成功响应的结构。
- **DTO 属性**: 在 DTO 类中，必须为每个属性配置 `@ApiProperty`，并提供以下信息：
  - `description`: 字段的中文描述。
  - `example`: 字段的示例值。
  - `required`: 明确字段是否必填。
  - `enum`: 如果字段是枚举类型，指明可选的枚举值。
- **验证规则**: DTO 属性应配合 `class-validator` 装饰器（如 `@IsNotEmpty()`, `@IsString()`）来定义验证逻辑。

**DTO 示例**:

```typescript
// create-user.dto.ts
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, IsEnum } from 'class-validator';
import { UserRole } from '../user.enum'; // 假设存在

export class CreateUserDto {
  @ApiProperty({
    description: '用户名',
    example: 'testuser',
    required: true,
  })
  @IsNotEmpty({ message: '用户名不能为空' })
  @IsString()
  readonly username: string;

  @ApiProperty({
    description: '用户角色',
    enum: UserRole,
    example: UserRole.Member,
    required: true,
  })
  @IsNotEmpty({ message: '角色不能为空' })
  @IsEnum(UserRole)
  readonly role: UserRole;
}
```

---

## 8. 状态码规范

### 8.1. HTTP 状态码

- **统一使用 `200 OK`**: 只要服务器能够成功响应请求（无论业务逻辑是否成功），HTTP 状态码都应为 `200`。
- **避免使用其他状态码**: 不使用 `4xx` 或 `5xx` 等 HTTP 状态码来传递业务错误信息。所有业务层面的状态都通过业务码在响应体中体现。

### 8.2. 业务码 (Business Code)

业务码用于在 HTTP 状态码的基础上，更精细地表达业务层面的状态。

- **`200`**: 表示业务处理完全成功。
- **分段编码**:
  - `1000-1999`: 通用错误
  - `2000-2999`: 认证相关错误
  - `3000-3999`: 用户相关错误
  - `4000-4999`: 权限相关错误
  - `5000-5999`: 角色相关错误
  - ... 以此类推

所有业务码及其对应的消息应在 `src/common/constants/error-codes.ts` 中统一定义。

---

## 9. 异常处理规范

### 9.1. 全局异常过滤器
- 使用 NestJS 提供的全局异常过滤器 (`@nestjs/common` 中的 `BaseExceptionFilter`) 或自定义过滤器统一处理未捕获的异常
- 自定义异常应继承 `HttpException` 或使用 NestJS 内置异常类型

### 9.2. 业务异常处理
- 对于业务逻辑中的错误情况，应抛出自定义业务异常，包含明确的错误码和消息
- 在控制器层捕获并记录异常日志（如使用 `@nestjs/common` 的 `Logger`）

---

## 10. 注释规范

### 10.1. 代码注释
- 对于复杂逻辑或算法，应添加行内注释或块注释解释其实现原理
- 使用 `//` 进行单行注释，`/* */` 进行多行注释
- 避免无意义的注释，注释应随代码更新保持同步

### 10.2. 函数/方法注释
- 使用 JSDoc 风格的注释为公共方法添加文档
- 标注参数类型、返回值类型、可能抛出的异常、功能描述等

```typescript
/**
 * 根据ID获取用户信息
 * @param userId - 用户ID
 * @returns Promise<User> - 用户信息对象
 * @throws {NotFoundException} - 当用户不存在时抛出
 */
async getUserById(userId: string): Promise<User> {
  // 实现逻辑
}
```

---

## 11. 安全规范

### 11.1. 输入验证
- 所有来自客户端的输入都必须进行严格验证，防止注入攻击
- 使用 `class-validator` 在 DTO 中定义验证规则
- 对于文件上传，应限制文件类型和大小

### 11.2. 敏感信息保护
- 敏感信息（如密码、密钥）不得在代码中硬编码
- 使用环境变量或配置中心存储敏感信息
- 对于敏感数据传输，应使用 HTTPS 协议

## 12. 单元测试规范

### 12.1. 断言语言
- 所有单元测试中的断言消息必须使用中文描述，以提高测试结果的可读性
- 断言应清晰表达预期行为和实际结果

### 12.2. 测试覆盖率
- 核心业务逻辑的测试覆盖率应达到 80% 以上
- 新增功能必须包含相应的单元测试

## 13. 核心规则

作为项目开发人员，必须严格遵守以下核心规则，确保代码质量和项目一致性：

1. **准确性原则**  
   优先调用官方文档解析接口，禁止无依据猜测API功能，确保代码调用准确性。

2. **沟通明确原则**  
   面对模糊需求或逻辑时，需主动提示用户补充细节、确认诉求，不盲目生成模糊代码。

3. **数据驱动原则**  
   生成业务相关代码方案前，需引导用户关联真实场景数据或用户反馈，辅助验证方案可行性，不基于空想生成代码。

4. **复用优先原则**  
   优先检索并复用现有成熟API、函数库或代码模块，无必要时不主动创建新接口或重复代码，减少冗余。

5. **验证保障原则**  
   生成代码后需自动触发基础验证（如语法检查、逻辑校验），主动提示用户补充测试用例，不生成未经基础验证的代码。

6. **架构一致原则**  
   遵循通用编程架构（如MVC、微服务规范）及行业代码标准，不生成破坏架构一致性、不符合规范的代码。

7. **诚实透明原则**  
   遇到未收录的API知识或不确定的技术细节时，需明确告知用户"当前无法确定该信息"，不编造代码逻辑或API用法。

8. **逻辑完整原则**  
   对用户提供的待优化代码，需先分析原有逻辑关联性，再生成结构化重构方案，禁止无逻辑的盲目修改（如随意删改变量、函数逻辑）。

9. **环境安全原则**  
   禁止修改.env环境配置文件。