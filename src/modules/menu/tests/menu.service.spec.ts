import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { MenuService } from '../services/menu.service';
import { PermissionService } from '../../permission/services/permission.service';
import { RoleService } from '../../role/services/role.service';
import { Menu } from '../entities/menu.entity';
import { Repository } from 'typeorm';
import { BusinessException } from '../../../common/exceptions/business.exception';
import { ERROR_CODES } from '../../../common/constants/error-codes';
import { CreateMenuDto } from '../dto/create-menu.dto';
import { UpdateMenuDto } from '../dto/update-menu.dto';
import { RoleType } from '../../../common/enums/role-type.enum';
import { PermissionType } from '../../../common/decorators/roles.decorator';

describe('MenuService', () => {
  let service: MenuService;
  let menuRepository: Repository<Menu>;
  let permissionService: PermissionService;
  let roleService: RoleService;

  // Mock data
  const mockMenu = {
    id: '1',
    name: 'Test Menu',
    path: '/test',
    status: 'active',
    parentId: null,
    sortOrder: 1,
    createdAt: new Date(),
    updatedAt: new Date(),
    autoGeneratedPermission: 'page:test:test-menu',
  } as Menu;

  const mockRole = {
    id: 'role1',
    name: 'test-role',
    type: RoleType.USER,
    permissions: [],
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        MenuService,
        {
          provide: getRepositoryToken(Menu),
          useValue: {
            find: jest.fn(),
            findOne: jest.fn(),
            findOneBy: jest.fn(),
            findBy: jest.fn(),
            create: jest.fn(),
            save: jest.fn(),
            merge: jest.fn(),
            delete: jest.fn(),
            count: jest.fn(),
            update: jest.fn(),
            preload: jest.fn(),
            findAndCount: jest.fn(),
            remove: jest.fn(),
          },
        },
        {
          provide: PermissionService,
          useValue: {
            create: jest.fn(),
            findByName: jest.fn(),
            updateByName: jest.fn(),
            removeByName: jest.fn(),
            findByIds: jest.fn(),
          },
        },
        {
          provide: RoleService,
          useValue: {
            findById: jest.fn(),
            findByName: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<MenuService>(MenuService);
    menuRepository = module.get<Repository<Menu>>(getRepositoryToken(Menu));
    permissionService = module.get<PermissionService>(PermissionService);
    roleService = module.get<RoleService>(RoleService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('findAll', () => {
    it('should return all menus in tree structure', async () => {
      const mockMenus = [mockMenu];
      (menuRepository.find as jest.Mock).mockResolvedValue(mockMenus);

      const result = await service.findAll();

      expect(menuRepository.find).toHaveBeenCalledWith({
        order: { sortOrder: 'ASC', createdAt: 'ASC' },
      });
      expect(result).toBeDefined();
      expect(Array.isArray(result)).toBe(true);
    });
  });

  describe('findOne', () => {
    it('should return a menu by id', async () => {
      (menuRepository.findOne as jest.Mock).mockResolvedValue(mockMenu);

      const result = await service.findOne('1');

      expect(menuRepository.findOne).toHaveBeenCalledWith({
        where: { id: '1' },
      });
      expect(result).toBeDefined();
    });

    it('should throw MENU_NOT_FOUND error if menu does not exist', async () => {
      (menuRepository.findOne as jest.Mock).mockResolvedValue(null);

      await expect(service.findOne('nonexistent')).rejects.toThrow(
        new BusinessException(ERROR_CODES.MENU_NOT_FOUND),
      );
    });
  });

  describe('findByRole', () => {
    it('should return all menus for super admin role', async () => {
      const superAdminRole = { ...mockRole, type: RoleType.SUPER_ADMIN };
      (roleService.findById as jest.Mock).mockResolvedValue(superAdminRole);
      (menuRepository.find as jest.Mock).mockResolvedValue([mockMenu]);

      const result = await service.findByRole('role1');

      expect(roleService.findById).toHaveBeenCalledWith('role1');
      expect(menuRepository.find).toHaveBeenCalledWith({
        where: { status: 'active' },
        order: { sortOrder: 'ASC', createdAt: 'ASC' },
      });
      expect(result).toBeDefined();
    });

    it('should return menus based on role permissions for non-super admin', async () => {
      const mockRoleWithPermissions = {
        ...mockRole,
        permissions: [{ id: 'perm1' }],
      };
      const mockPermission = { id: 'perm1', name: 'page:test:test-menu' };

      (roleService.findById as jest.Mock).mockResolvedValue(
        mockRoleWithPermissions,
      );
      (permissionService.findByIds as jest.Mock).mockResolvedValue([
        mockPermission,
      ]);
      (menuRepository.find as jest.Mock).mockResolvedValue([mockMenu]);

      const result = await service.findByRole('role1');

      expect(roleService.findById).toHaveBeenCalledWith('role1');
      expect(permissionService.findByIds).toHaveBeenCalledWith(['perm1']);
      expect(menuRepository.find).toHaveBeenCalledWith({
        where: {
          status: 'active',
          autoGeneratedPermission: 'page:test:test-menu',
        },
        order: { sortOrder: 'ASC', createdAt: 'ASC' },
      });
      expect(result).toBeDefined();
    });

    it('should return empty array if role has no permissions', async () => {
      const roleWithoutPermissions = { ...mockRole, permissions: [] };
      (roleService.findById as jest.Mock).mockResolvedValue(
        roleWithoutPermissions,
      );

      const result = await service.findByRole('role1');

      expect(result).toEqual([]);
    });
  });

  describe('create', () => {
    it('should create a menu and generate permission', async () => {
      const createMenuDto: CreateMenuDto = {
        name: 'New Menu',
        path: '/new-menu',
        status: 'active',
      };

      const savedMenu = { ...mockMenu, ...createMenuDto, id: '2' };

      (menuRepository.create as jest.Mock).mockReturnValue(savedMenu);
      (menuRepository.save as jest.Mock).mockResolvedValue(savedMenu);
      (permissionService.create as jest.Mock).mockResolvedValue(undefined);

      const result = await service.create(createMenuDto);

      expect(menuRepository.create).toHaveBeenCalledWith(createMenuDto);
      expect(permissionService.create).toHaveBeenCalled();
      expect(result).toBeDefined();
    });
  });

  describe('update', () => {
    it('should update a menu', async () => {
      const updateMenuDto: UpdateMenuDto = {
        id: '1',
        name: 'Updated Menu',
        status: 'active',
      };

      (menuRepository.findOne as jest.Mock).mockResolvedValue(mockMenu);
      (menuRepository.save as jest.Mock).mockResolvedValue({
        ...mockMenu,
        name: 'Updated Menu',
      });
      (permissionService.findByName as jest.Mock).mockResolvedValue(null);
      (permissionService.create as jest.Mock).mockResolvedValue(undefined);

      const result = await service.update(updateMenuDto);

      expect(menuRepository.findOne).toHaveBeenCalledWith({
        where: { id: '1' },
      });
      expect(result).toBeDefined();
    });

    it('should throw MENU_NOT_FOUND error if menu does not exist', async () => {
      (menuRepository.findOne as jest.Mock).mockResolvedValue(null);

      await expect(
        service.update({
          id: 'nonexistent',
          status: 'active',
        } as UpdateMenuDto),
      ).rejects.toThrow(new BusinessException(ERROR_CODES.MENU_NOT_FOUND));
    });
  });

  describe('delete', () => {
    it('should delete a menu and its associated permission', async () => {
      const mockMenuToDelete = {
        id: '1',
        name: 'Test Menu',
        path: '/test',
        status: 'active',
        parentId: null,
        sortOrder: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
        autoGeneratedPermission: 'page:test:test-menu',
      } as Menu;

      (menuRepository.findOne as jest.Mock).mockResolvedValue(mockMenuToDelete);
      (menuRepository.remove as jest.Mock).mockResolvedValue(undefined);
      (permissionService.removeByName as jest.Mock).mockResolvedValue(
        undefined,
      );

      await service.delete('1');

      expect(menuRepository.findOne).toHaveBeenCalledWith({
        where: { id: '1' },
      });
      expect(permissionService.removeByName).toHaveBeenCalledWith(
        'page:test:test-menu',
      );
      expect(menuRepository.remove).toHaveBeenCalledWith(mockMenuToDelete);
    });

    it('should throw MENU_NOT_FOUND error if menu does not exist', async () => {
      (menuRepository.findOne as jest.Mock).mockResolvedValue(null);

      await expect(service.delete('nonexistent')).rejects.toThrow(
        new BusinessException(ERROR_CODES.MENU_NOT_FOUND),
      );
    });
  });

  describe('buildMenuTree', () => {
    it('should build a tree structure from flat menu array', () => {
      const flatMenus = [
        { id: '1', name: 'Parent', parentId: null, sortOrder: 1 } as Menu,
        { id: '2', name: 'Child', parentId: '1', sortOrder: 1 } as Menu,
      ];

      const tree = (service as any).buildMenuTree(flatMenus);

      expect(tree.length).toBe(1);
      expect(tree[0].id).toBe('1');
      expect(tree[0].children.length).toBe(1);
      expect(tree[0].children[0].id).toBe('2');
    });
  });

  describe('getModuleFromPath', () => {
    it('should extract module from path', () => {
      expect((service as any).getModuleFromPath('/system/user')).toBe('system');
      expect((service as any).getModuleFromPath('/')).toBe('general');
      expect((service as any).getModuleFromPath('/test/')).toBe('test');
    });
  });

  describe('getPermissionName', () => {
    it('should convert menu name to permission name', () => {
      expect((service as any).getPermissionName('User Management')).toBe(
        'user-management',
      );
      expect((service as any).getPermissionName('Admin Panel')).toBe(
        'admin-panel',
      );
      expect((service as any).getPermissionName('Dashboard')).toBe('dashboard');
    });
  });

  describe('isPermissionObject', () => {
    it('should correctly identify permission objects', () => {
      expect((service as any).isPermissionObject({ id: '123' })).toBe(true);
      expect((service as any).isPermissionObject({ id: 123 })).toBe(false); // id is not string
      expect((service as any).isPermissionObject({ name: 'test' })).toBe(false); // no id property
      expect((service as any).isPermissionObject(null)).toBe(false);
      expect((service as any).isPermissionObject('string')).toBe(false);
    });
  });
});
