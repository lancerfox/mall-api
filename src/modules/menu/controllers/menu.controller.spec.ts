import { Test, TestingModule } from '@nestjs/testing';
import { HttpException } from '@nestjs/common';
import { MenuController } from './menu.controller';
import { MenuService } from '../services/menu.service';
import { RoleService } from '../../role/services/role.service';
import { ERROR_CODES } from '../../../common/constants/error-codes';
import { Types } from 'mongoose';

describe('MenuController', () => {
  let controller: MenuController;
  let menuService: jest.Mocked<MenuService>;
  let roleService: jest.Mocked<RoleService>;

  // 测试数据
  const mockMenu = {
    _id: new Types.ObjectId(),
    id: new Types.ObjectId().toString(),
    parentId: null,
    path: '/system/user',
    name: '用户管理',
    component: 'UserManagement',
    metaTitle: '用户管理',
    metaIcon: 'user',
    metaHidden: false,
    metaAlwaysShow: false,
    sortOrder: 1,
    status: 'active',
    autoGeneratedPermission: 'page:system:用户管理',
    createdAt: new Date(),
    updatedAt: new Date(),
    children: [],
  };

  const mockMenuList = [
    {
      id: new Types.ObjectId().toString(),
      parentId: undefined,
      path: '/system',
      name: '系统管理',
      component: 'Layout',
      meta: {
        title: '系统管理',
        icon: 'system',
        hidden: false,
        alwaysShow: false,
      },
      sortOrder: 1,
      status: 'active',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      children: [],
    },
    {
      id: new Types.ObjectId().toString(),
      parentId: undefined,
      path: '/system/user',
      name: '用户管理',
      component: 'UserManagement',
      meta: {
        title: '用户管理',
        icon: 'user',
        hidden: false,
        alwaysShow: false,
      },
      sortOrder: 2,
      status: 'active',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      children: [],
    },
  ];

  const mockRole = {
    _id: new Types.ObjectId(),
    id: new Types.ObjectId().toString(),
    name: '管理员',
    description: '管理员角色',
    type: 'admin',
    permissions: [],
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [MenuController],
      providers: [
        {
          provide: MenuService,
          useValue: {
            findAll: jest.fn(),
            findOne: jest.fn(),
            findByRole: jest.fn(),
            create: jest.fn(),
            update: jest.fn(),
            delete: jest.fn(),
          },
        },
        {
          provide: RoleService,
          useValue: {
            findByName: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = module.get<MenuController>(MenuController);
    menuService = module.get(MenuService);
    roleService = module.get(RoleService);

    // 重置所有 mock
    jest.clearAllMocks();
  });

  describe('getMenus', () => {
    it('应该根据用户角色返回菜单列表', async () => {
      // 安排
      const roleName = '管理员';
      roleService.findByName.mockResolvedValue(mockRole as any);
      menuService.findByRole.mockResolvedValue(mockMenuList as any);

      // 执行
      const result = await controller.getMenus(roleName);

      // 断言
      expect(roleService.findByName).toHaveBeenCalledWith(roleName);
      expect(menuService.findByRole).toHaveBeenCalledWith(mockRole.id);
      expect(result).toEqual({ data: mockMenuList });
    });

    it('角色不存在时应该返回空菜单列表', async () => {
      // 安排
      const roleName = '不存在的角色';
      roleService.findByName.mockResolvedValue(null);

      // 执行
      const result = await controller.getMenus(roleName);

      // 断言
      expect(roleService.findByName).toHaveBeenCalledWith(roleName);
      expect(menuService.findByRole).not.toHaveBeenCalled();
      expect(result).toEqual({ data: [] });
    });
  });

  describe('getMenusByRole', () => {
    it('应该根据角色ID返回菜单列表', async () => {
      // 安排
      const requestBody = { roleId: mockRole.id };
      menuService.findByRole.mockResolvedValue(mockMenuList as any);

      // 执行
      const result = await controller.getMenusByRole(requestBody);

      // 断言
      expect(menuService.findByRole).toHaveBeenCalledWith(requestBody.roleId);
      expect(result).toEqual({ data: mockMenuList });
    });
  });

  describe('getMenuDetail', () => {
    it('应该返回指定菜单的详细信息', async () => {
      // 安排
      const requestBody = { id: mockMenu.id };
      menuService.findOne.mockResolvedValue(mockMenu as any);

      // 执行
      const result = await controller.getMenuDetail(requestBody);

      // 断言
      expect(menuService.findOne).toHaveBeenCalledWith(requestBody.id);
      expect(result).toEqual({ data: mockMenu });
    });

    it('菜单不存在时应该传递服务层的错误', async () => {
      // 安排
      const requestBody = { id: 'nonexistent-id' };
      const expectedError = new HttpException(
        '菜单不存在',
        ERROR_CODES.MENU_NOT_FOUND,
      );
      menuService.findOne.mockRejectedValue(expectedError);

      // 执行和断言
      await expect(controller.getMenuDetail(requestBody)).rejects.toThrow(
        expectedError,
      );
    });
  });

  describe('createMenu', () => {
    it('应该成功创建菜单', async () => {
      // 安排
      const createMenuDto = {
        path: '/test/menu',
        name: '测试菜单',
        component: 'TestMenu',
        metaTitle: '测试菜单',
        metaIcon: 'test',
      };

      menuService.create.mockResolvedValue(mockMenu as any);

      // 执行
      const result = await controller.createMenu(createMenuDto);

      // 断言
      expect(menuService.create).toHaveBeenCalledWith(createMenuDto);
      expect(result).toEqual({ data: mockMenu });
    });

    it('重复路径应该传递服务层的错误', async () => {
      // 安排
      const createMenuDto = {
        path: '/existing/path',
        name: '重复路径菜单',
        component: 'ExistingMenu',
      };

      const expectedError = new HttpException(
        '菜单路径已存在',
        ERROR_CODES.VALIDATION_FAILED,
      );
      menuService.create.mockRejectedValue(expectedError);

      // 执行和断言
      await expect(controller.createMenu(createMenuDto)).rejects.toThrow(
        expectedError,
      );
    });
  });

  describe('updateMenu', () => {
    it('应该成功更新菜单信息', async () => {
      // 安排
      const updateMenuDto = {
        id: mockMenu.id,
        name: '更新后的菜单名',
        metaTitle: '更新后的标题',
      };

      const updatedMenu = { ...mockMenu, ...updateMenuDto };
      menuService.update.mockResolvedValue(updatedMenu as any);

      // 执行
      const result = await controller.updateMenu(updateMenuDto);

      // 断言
      expect(menuService.update).toHaveBeenCalledWith(updateMenuDto);
      expect(result).toEqual({ data: updatedMenu });
    });

    it('更新不存在的菜单应该传递服务层的错误', async () => {
      // 安排
      const updateMenuDto = {
        id: 'nonexistent-id',
        name: '更新菜单',
      };

      const expectedError = new HttpException(
        '菜单不存在',
        ERROR_CODES.MENU_NOT_FOUND,
      );
      menuService.update.mockRejectedValue(expectedError);

      // 执行和断言
      await expect(controller.updateMenu(updateMenuDto)).rejects.toThrow(
        expectedError,
      );
    });
  });

  describe('deleteMenu', () => {
    it('应该成功删除菜单', async () => {
      // 安排
      const requestBody = { id: mockMenu.id };
      menuService.delete.mockResolvedValue(undefined);

      // 执行
      const result = await controller.deleteMenu(requestBody);

      // 断言
      expect(menuService.delete).toHaveBeenCalledWith(requestBody.id);
      expect(result).toEqual({ message: '删除成功' });
    });

    it('删除不存在的菜单应该传递服务层的错误', async () => {
      // 安排
      const requestBody = { id: 'nonexistent-id' };
      const expectedError = new HttpException(
        '菜单不存在',
        ERROR_CODES.MENU_NOT_FOUND,
      );
      menuService.delete.mockRejectedValue(expectedError);

      // 执行和断言
      await expect(controller.deleteMenu(requestBody)).rejects.toThrow(
        expectedError,
      );
    });
  });
});
